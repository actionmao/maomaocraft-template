/*
package com.actionmao.maomaocraft.item.custom;

import com.actionmao.maomaocraft.tags.ModBlockTags;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.entity.EquipmentSlot;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.Item;
import net.minecraft.item.ItemUsageContext;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.text.Text;
import net.minecraft.util.ActionResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
//AI导入
import net.minecraft.entity.ItemEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.particle.DustParticleEffect;
import net.minecraft.particle.ParticleEffect;
import net.minecraft.sound.SoundCategory;
import net.minecraft.sound.SoundEvents;
import org.joml.Vector3f;





import java.util.ArrayList;

public class TempMiner extends Item {
    //采矿器
    public TempMiner(Settings settings) {
        super(settings);
    }


    //属性
    public static final int INITIAL_SHORT_COUNT = 63;
    public static final int INITIAL_COUNT = 1;
    //基础方法
    //1.探测(prospect)


    //功能:检测特定范围的方块是否是矿石
    //形式参数:范围,位置,隔空连锁剩余次数,邻近连锁剩余次数
    public void prospect(PlayerEntity player, World world, int round, BlockPos pos, int count, int shortCount) {
        //定义列表存储已破坏方块的坐标
        ArrayList<BlockPos> list = new ArrayList<>();
        int StartY = Math.min((pos.getY() + 64), (round / 2));
        for (int y = -StartY; y <= round / 2; y++) {
            for (int x = -(round / 2); x <= round / 2; x++) {
                for (int z = -(round / 2); z <= round / 2; z++) {
                    //目标方块的坐标
                    BlockPos searchedBlockPos = pos.up(y).north(x).east(z);
                    //获取目标方块的名字
                    BlockState blockState = world.getBlockState(searchedBlockPos);
                    String blockName = blockState.getBlock().getName().getString();
                    if (isRightBlock(blockState)) {
                        //表明找到了目标方块
                        player.sendMessage(Text.of("Found " + blockName));
                        //1.将方块坐标存入列表
                        list.add(searchedBlockPos);
                        //2.破坏方块(此处为AI补全damageBlock方法的地方)
                        //补全要求
                        //<1>破坏后有矿物对应颜色的粒子效果(类似烟花,且产生烟花爆炸声)
                        //<2>产生掉落物,产生后立即按一定速度直线回到玩家身边
                        damageBlock(searchedBlockPos, blockState, world, player);
                        //3.shortCount--
                        shortCount--;
                        //4.如果shortCount >= 0,以3*3*3范围递归本方法
                        if (shortCount >= 0) {
                            prospect(player, world, 3, searchedBlockPos, 1, shortCount);
                        }

                    }
                }
            }
        }

        //区域方块遍历完毕
        count--;
        if (count <= 0) return;
        //获取每一个list中的坐标
        for (BlockPos blockPos : list) {
            //count此时是剩余隔空连锁次数
            prospect(player, world, round, blockPos, count, shortCount);
        }



    }

    private boolean isRightBlock(BlockState blockState) {
        return blockState.isIn(ModBlockTags.ORE_LIST);
    }

    @Override
    public ActionResult useOnBlock(ItemUsageContext context) {
        BlockPos pos = context.getBlockPos();
        PlayerEntity player = context.getPlayer();
        World world = context.getWorld();

        if (!world.isClient) {
            //是服务端
            boolean foundBlock = false;
            if (!Screen.hasShiftDown()) {
                //5x5x5
                prospect(player, world, 5, pos, INITIAL_COUNT, INITIAL_SHORT_COUNT);
                assert player != null;
                context.getStack().damage(1, player, EquipmentSlot.MAINHAND);

            } else {
                //13x13x13
                prospect(player, world, 13, pos, INITIAL_COUNT, INITIAL_SHORT_COUNT);
                assert player != null;
                context.getStack().damage(3, player, EquipmentSlot.MAINHAND);
            }
            return ActionResult.SUCCESS;
        }
        return super.useOnBlock(context);
    }

    //请把补全的代码写到此处
    //注意:是AI写的,以下全是!
    //破坏方块并处理相关效果的方法
    private void damageBlock(BlockPos pos, BlockState state, World world, PlayerEntity player) {
        ServerWorld serverWorld = (ServerWorld) world;
        // 仅在服务端执行方块破坏和掉落逻辑
        if (!world.isClient) {
            // 破坏方块
            boolean broken = world.breakBlock(pos, false, player);

            if (broken) {
                // 获取方块掉落物
                java.util.List<ItemStack> drops = Block.getDroppedStacks(state, serverWorld, pos, world.getBlockEntity(pos), player, ItemStack.EMPTY);

                // 为每个掉落物创建物品实体并设置飞向玩家的速度
                for (ItemStack stack : drops) {
                    ItemEntity itemEntity = new ItemEntity(world, pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5, stack);
                    world.spawnEntity(itemEntity);

                    // 计算物品飞向玩家的速度向量
                    if (player != null) {
                        double dx = player.getX() - itemEntity.getX();
                        double dy = player.getY() + player.getStandingEyeHeight() - itemEntity.getY();
                        double dz = player.getZ() - itemEntity.getZ();
                        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        // 设置速度，距离越远速度稍快，确保物品能到达玩家
                        double speed = 0.15 + (distance * 0.01);
                        itemEntity.setVelocity(dx / distance * speed, dy / distance * speed, dz / distance * speed);
                    }
                }

                */
/*//*
/ 在客户端播放粒子效果和声音（通过网络发送包）
                world.sendPacketToNearbyPlayers(
                        player,
                        pos,
                        new ParticleS2CPacket(
                                getParticleType(state),
                                false,
                                pos.getX() + 0.5,
                                pos.getY() + 0.5,
                                pos.getZ() + 0.5,
                                0.5f,
                                0.5f,
                                0.5f,
                                0.1f,
                                15
                        )
                );*//*







                // 播放烟花爆炸声
                world.playSound(
                        null,
                        pos,
                        SoundEvents.ENTITY_FIREWORK_ROCKET_BLAST,
                        SoundCategory.BLOCKS,
                        1.0f,
                        1.0f
                );
            }
        }
    }

    // 根据方块类型获取对应的粒子效果
    private ParticleEffect getParticleType(BlockState state) {
        if (state.isOf(Blocks.DIAMOND_ORE)) {
            // 钻石矿使用蓝色粒子
            return new DustParticleEffect(new Vector3f(0.0f, 1.0f, 1.0f), 1.0f);
        } else if (state.isOf(Blocks.IRON_ORE)) {
            // 铁矿使用棕色/金色粒子
            return new DustParticleEffect(new Vector3f(0.8f, 0.6f, 0.2f), 1.0f);
        }
        // 默认使用白色粒子
        return new DustParticleEffect(new Vector3f(1.0f, 1.0f, 1.0f), 1.0f);
    }

// 同时需要在prospect方法中修改调用方式，添加player参数
// 修改prospect方法中的调用：
// damageBlock(searchedBlockPos, blockState, world, player);
}
*/
